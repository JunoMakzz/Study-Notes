## 线程创建

### 三种创建线程的方式

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624090508451-1432499193.png)

### 继承Thread

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624090528864-451045459.png)
.start() 方法启动线程执行的是 run() 里的线程体！

**测试一：**

```java
// 创建线程方式一：继承Thread类，重写run()方法，调用start开启线程
//总结：注意，线程开启不一定立即执行，由cpu调度执行
public class TestThread1 extends Thread{

    @Override
    public void run(){
        //run方法线程体
        for (int i = 0;i<20;i++){
            System.out.println("我在看代码-----"+i);
        }
    }

    public static void main(String[] args){
        //main线程，主线程

        //创建一个线程对象
        TestThread1 testThread1 = new TestThread1();
        //调用start()方法开启线程
        testThread1.start();

        for(int i= 0 ;i<200;i++){
            System.out.println("我在学习多线程----"+i);
       }
    }
}
```

输出结果：

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624090626063-1976297678.png)

可以发现 start() 开启的线程和主线程是交替执行的！！！

而直接调用 run() 方法，会发现先执行run()方法，再执行主线程：

```java
public static void main(String[] args){
        //main线程，主线程

        //创建一个线程对象
        TestThread1 testThread1 = new TestThread1();

        //调用run()方法开启线程
        testThread1.run();

        for(int i= 0 ;i<200;i++){
            System.out.println("我在学习多线程----"+i);
        }
    }
```

输出结果

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624090645438-1874304810.png)

**以上对比直接调用 run() 和调用 start()可以得出以下结论：**

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624090711547-726801160.png)

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624090735408-544808969.png)

为了更好地验证上述结论，我们进行测试二：

**测试二：**

```java
//练习Thread,实现多线程同步下载图片
public class TestThread2 extends Thread {

    private String url;  //网络图片地址
    private String name;  //保存的文件名

    public TestThread2(String url,String name){
        this.url=url;
        this.name=name;
    }

    //下载图片的线程执行体
    @Override
    public void run(){
        WebDownloader webDownloader = new WebDownloader();
        webDownloader.downloader(url,name);
        System.out.println("下载的文件名为："+name);
    }

    public static void main(String[] args) {
        TestThread2 t1 = new TestThread2("https://pics7.baidu.com/feed/a50f4bfbfbedab64cddfc490f31fc9c578311ee4.jpeg?token=d6cc78140999ca5390cd8002a754d9a4","1.jpg");
        TestThread2 t2 = new TestThread2("https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628161248586-632368241.png","2.jpg");
        TestThread2 t3 = new TestThread2("https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628162624243-370438535.png","3.jpg");

        t1.start();
        t2.start();
        t3.start();

    }

}

//下载器
class WebDownloader{
    //下载方法
    public void downloader(String url,String name){
        try{
            FileUtils.copyURLToFile(new URL(url),new File(name));
        }catch (IOException e){
            e.printStackTrace();
            System.out.println("IO异常，downloader方法出现问题");
        }

    }
```

下载结果为：（发现并不是按1，2，3的顺序下载）

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624090757749-1762944389.png)

从而更好的说明，start() 方法开启的子线程和主线程是并行交替执行的！

### 实现Runnable

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624090811884-240684240.png)

测试一：

```java
//创建线程方式2：实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类Thread中，调用start()。
public class TestThread3 implements Runnable{

    @Override
    public void run(){
        //run方法线程体
        for (int i = 0;i<20;i++){
            System.out.println("我在看代码-----"+i);
        }
    }

    public static void main(String[] args){
        //创建runnable接口的实现类对象
        TestThread3 testThread3 = new TestThread3();

        //创建线程对象，通过线程对象来开启我们的线程，代理
        Thread thread = new Thread(testThread3);
        thread.start();

        for(int i= 0 ;i<200;i++){
            System.out.println("我在学习多线程----"+i);
        }
    }

}
```

输出结果：

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624090836519-1618424269.png)

测试二：让TestThread2实现Runnable接口下载图片，而非继承Thread

```java
//实现Runnable接口下载图片
public class TestThread2 implements Runnable {

    private String url;  //网络图片地址
    private String name;  //保存的文件名

    public TestThread2(String url,String name){
        this.url=url;
        this.name=name;
    }

    //下载图片的线程执行体
    @Override
    public void run(){
        WebDownloader webDownloader = new WebDownloader();
        webDownloader.downloader(url,name);
        System.out.println("下载的文件名为："+name);
    }

    public static void main(String[] args) {
        TestThread2 t1 = new TestThread2("https://pics7.baidu.com/feed/a50f4bfbfbedab64cddfc490f31fc9c578311ee4.jpeg?token=d6cc78140999ca5390cd8002a754d9a4","1.jpg");
        TestThread2 t2 = new TestThread2("https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628161248586-632368241.png","2.jpg");
        TestThread2 t3 = new TestThread2("https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628162624243-370438535.png","3.jpg");

        new Thread(t1).start();
        new Thread(t2).start();
        new Thread(t3).start();

    }

}
```

下载结果：（交替下载，而非顺序下载）

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624090854460-182659960.png)

### 小结

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624090933489-328680631.png)

### 初识并发问题

```java
//多个线程同时操作同一个对象
//买车票的例子

//发现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱
public class TestThread4 implements Runnable {

    //票数
    private int ticketNums = 10;

    @Override
    public void run(){
        while(true){
            if (ticketNums<=0){
                break;
            }
            //模拟延时
            try{
                Thread.sleep(200);
            }catch (InterruptedException e){
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName()+"拿到了第"+ticketNums--+"张票");
        }
    }

    public static void main(String[] args) {
        TestThread4 ticket = new TestThread4();
        new Thread(ticket,"小明").start();
        new Thread(ticket,"老师").start();
        new Thread(ticket,"黄牛").start();
    }
}
```

输出结果：（发现线程不安全）
![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624090953932-1148926129.png)

### 案例：龟兔赛跑—Race

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091033827-1556985926.png)

```java
//模拟龟兔赛跑
public class Race implements Runnable {

    //胜利者
    private static String winner;

    @Override
    public void run(){
        for (int i = 1; i<=100 ; i++){

            //模拟兔子休息
            if(Thread.currentThread().getName().equals("兔子") && i%10==0){
                try{
                    Thread.sleep(10);
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
            }

            //判断比赛是否结束
            boolean flag = gameOver(i);
            //如果比赛结束了，就停止程序
            if (flag){
                break;
            }
            System.out.println(Thread.currentThread().getName()+"---->跑了"+i+"步");
        }
    }

    //判断是否完成比赛
    private boolean gameOver(int steps){
        //判断是否有胜利者
        if (winner!=null){ //已经有胜利者
            return true;
        }else{
            if (steps>=100){
                winner = Thread.currentThread().getName();
                System.out.println("winner is "+winner);
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {

        Race race = new Race();

        new Thread(race,"兔子").start();
        new Thread(race,"乌龟").start();
    }
}
```

### 实现Callable接口（了解即可）

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091059494-288755475.png)

```java
//线程创建方式三：实现callable接口
/*
* callable的好处
* 1.可以定义返回值
* 2.可以抛出异常
* */
public class TestCallable implements Callable<Boolean> {


    private String url;  //网络图片地址
    private String name;  //保存的文件名

    public TestCallable(String url,String name){
        this.url=url;
        this.name=name;
    }

    //下载图片的线程执行体
    @Override
    public Boolean call(){
        WebDownloader webDownloader = new WebDownloader();
        webDownloader.downloader(url,name);
        System.out.println("下载的文件名为："+name);
        return true;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        TestCallable t1 = new TestCallable("https://pics7.baidu.com/feed/a50f4bfbfbedab64cddfc490f31fc9c578311ee4.jpeg?token=d6cc78140999ca5390cd8002a754d9a4","1.jpg");
        TestCallable t2 = new TestCallable("https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628161248586-632368241.png","2.jpg");
        TestCallable t3 = new TestCallable("https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628162624243-370438535.png","3.jpg");

        //创建执行服务
        ExecutorService ser = Executors.newFixedThreadPool(3);
        //提交执行
        Future<Boolean> r1 = ser.submit(t1);
        Future<Boolean> r2 = ser.submit(t2);
        Future<Boolean> r3 = ser.submit(t3);
        //获取结果
        boolean rs1 = r1.get();
        boolean rs2 = r2.get();
        boolean rs3 = r3.get();

        System.out.println(rs1);
        System.out.println(rs2);
        System.out.println(rs3);
        //关闭服务
        ser.shutdownNow();

    }

}

//下载器
class WebDownloader{
    //下载方法
    public void downloader(String url,String name){
        try{
            FileUtils.copyURLToFile(new URL(url),new File(name));
        }catch (IOException e){
            e.printStackTrace();
            System.out.println("IO异常，downloader方法出现问题");
        }

    }
}
```

下载结果：
![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091127997-814254704.png)

## 静态代理

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091152266-1276885982.png)

```java
//静态代理模式总结：
    //真实对象和代理对象都要实现同一个接口
    //代理对象要代理真实角色

//好处：
    //代理对象可以做很多真实对象做不了的事情
    //真实对象专注做自己的事情

public class StaticProxy {

    public static void main(String[] args) {

        You you = new You();//你要结婚
        WeddingCompany weddingCompany = new WeddingCompany(you);
        weddingCompany.HappyMarry();
    }
}

interface Marry{

    void HappyMarry();
}

//真实角色，你去结婚
class You implements Marry{
    @Override
    public void HappyMarry(){
        System.out.println("秦老师要结婚了，超开心");
    }
}

//代理角色，帮助你结婚
class WeddingCompany implements Marry{

    //代理谁-> 真实目标角色
    private Marry target;

    public WeddingCompany(Marry target){
        this.target = target;
    }

    @Override
    public void HappyMarry(){
        before();
        this.target.HappyMarry(); //这就是真实对象
        after();
    }

    private void after(){
        System.out.println("结婚后，收尾款");
    }

    private void before(){
        System.out.println("结婚前，布置现场");
    }
```

和上文**实现Runnable接口创建线程**作对比：

​	Marry接口——>Runnable接口

​	实现Marry接口的You类——>实现Runnable接口的TestThread3类

​	实现Marry接口的WeddingCompany类——>实现Runnable接口的Thread类

## Lambda表达式

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091330689-1317892255.png)
![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091403859-505810110.png)
![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091428603-886952764.png)

```java
/**
 * 推导lambda表达式: 
 *      1.创建外部类——>2.创建静态内部类——>3.创建局部内部类——>4.创建匿名内部类——>5.使用lambda表达式
 */
public class TestLambda {

    //3.静态内部类
    static class Like2 implements ILike{
        @Override
        public void lambda(){
            System.out.println("I like lambda2");
        }
    }

    public static void main(String[] args) {
		
        //调用外部类创建对象
        ILike like1 = new Like();
        like1.lambda();
		
        //调用静态内部类创建对象
        ILike like2 = new Like2();
        like2.lambda();


        //4.局部内部类
        class Like3 implements ILike{
            @Override
            public void lambda(){
                System.out.println("I like lambda3");
            }
        }
        ILike like3 = new Like3();
        like3.lambda();

        //5.匿名内部类，没有类名字，必须借助接口或者父类
        ILike like4 = new ILike() {
            @Override
            public void lambda() {
                System.out.println("I like lambda4");
            }
        };
        like4.lambda();

        //6.用lambda简化
        ILike like5 = ()->{
            System.out.println("I like lambda5");
        };
        like5.lambda();
    }
}

//1.定义一个函数接口
interface ILike{
    void lambda();
}

//2.实现外部类
class Like implements ILike{
    @Override
    public void lambda(){
        System.out.println("I like lambda");
    }
}
```

在函数式接口的抽象函数有参数的情况下，使用lambda表达式：

```java
public class TestLambda2 {

    public static void main(String[] args) {
        
		//使用lambda表达式，不做任何化简
        ILove love1 = (int a)->{
                System.out.println("I love you-->"+a);
            };
        love1.love(1);

        //1.简化参数类型
        ILove love2 = (a)->{
            System.out.println("I love you-->"+a);
        };
        love2.love(2);

        //2.简化括号和参数类型
        ILove love3 = a->{
            System.out.println("I love you-->"+a);
        };
        love2.love(3);

        //3.简化括号和参数类型和花括号
        ILove love4 = a->System.out.println("I love you-->"+a);
        love4.love(4);

        //总结：
            //lambda表达式只能在方法体有一行代码的情况下才能简化成为一行(即去掉花括号)，如果有多行，那么就用代码块包裹(即使用花括号)
            //lambda的使用前提是接口为函数式接口（即接口里只有一个函数方法）
            //多个参数也可以去掉参数类型(参数类型不同也可以)，要去掉就都去掉，但必须加括号
            //当使用lambda有返回值时，方法体即使只有一行代码，也要用花括号包裹！
    }
}

//函数式接口
interface ILove{
    void love(int a);
}
```

## 线程状态

### 线程的五大状态

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091458251-920476868.png)

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091522731-2077860893.png)

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091538477-798895189.png)

### 停止线程

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091605627-212010639.png)

使用我们自定义的stop方法，通过改变标志位让线程停止：

```java
//测试stop
//1.建议线程正常停止————>利用次数，不建议死循环
//2.建议使用标志位————>设置一个标志位
//3.不要使用stop或者destroy等过时或者JDK不建议使用的方法
public class TestStop implements Runnable{

    //1.设置一个标识位
    private boolean flag = true;

    @Override
    public void run(){
        int i = 0;
        while(flag){
            System.out.println("run ..... Thread"+i++);
        }
    }

    //2.设置一个公开的方法停止线程，转换标志位
    public void stop(){
        this.flag = false;
    }

    public static void main(String[] args) {

        TestStop testStop = new TestStop();
        new Thread(testStop).start();

        for (int i=0;i<1000;i++){
            System.out.println("main"+i);
            if (i==900){
                //调用 stop方法切换标志位，让线程停止
                testStop.stop();
                System.out.println("线程该停止了！！！");
            }
        }
    }
}
```

线程在执行第1060次时停止：

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091621312-1431643226.png)

### 线程休眠

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091651594-2072059399.png)

```java
import com.ztx.dem01.TestThread4;

//模拟网络延时：放大问题的发生行
public class TestSleep implements Runnable{

    //票数
    private int ticketNums = 10;

    @Override
    public void run(){
        while(true){
            if (ticketNums<=0){
                break;
            }
            //模拟延时
            try{
                Thread.sleep(200);
            }catch (InterruptedException e){
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName()+"拿到了第"+ticketNums--+"张票");
        }
    }

    public static void main(String[] args) {
        TestThread4 ticket = new TestThread4();
        new Thread(ticket,"小明").start();
        new Thread(ticket,"老师").start();
        new Thread(ticket,"黄牛").start();
    }
}
```

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091719929-113698954.png)

```java
//模拟倒计时
public class TestSleep2 {

    public static void main(String[] args) {

        try {
            tenDown();
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }

    //模拟倒计时
    public static void tenDown() throws InterruptedException{
        int num = 10;
        while(true){
            Thread.sleep(1000);
            System.out.println(num--);
            if (num<=0){
                break;
            }
        }
    }
}
```

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091747447-563997313.png)

```java
//模拟倒计时
public class TestSleep2 {

    public static void main(String[] args) {
        //打印当前系统时间
        Date startTime = new Date(System.currentTimeMillis());//获取当前系统时间

        while(true){
            try{
                Thread.sleep(1000);
                System.out.println(new SimpleDateFormat("HH:MM:SS").format(startTime));
                startTime = new Date(System.currentTimeMillis());//更新当前系统时间
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    }
}
```

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091809170-463379131.png)

### 线程礼让

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091831606-1975451672.png)

```java
//测试礼让线程
//礼让不一定成功，看cpu心情
public class TestYield {

    public static void main(String[] args) {
        MyYield myYield = new MyYield();

        new Thread(myYield,"a").start();
        new Thread(myYield,"b").start();
    }

}

class MyYield implements Runnable{

    @Override
    public void run(){
        System.out.println(Thread.currentThread().getName()+"线程开始执行");
        Thread.yield();//礼让
        System.out.println(Thread.currentThread().getName()+"线程停止执行");
    }
}
```

理想情况下，当把 Thread.yield(); 注释掉，输出情况应为：（实际上，不可能这么理想！）

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091919857-2088581906.png)

加上礼让代码后，输出情况可能就不会很规整：（让执行的线程暂停，但不阻塞）

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624091943903-940895672.png)

### join

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624092001266-2068450763.png)

```java
//测试join方法
//想象为插队
public class TestJoin implements Runnable{

    @Override
    public void run(){
        for (int i=0;i<1000;i++){
            System.out.println("线程vip来了"+i);
        }
    }

    public static void main(String[] args) throws InterruptedException {

        //启动我们的线程
        TestJoin testJoin = new TestJoin();
        Thread thread = new Thread(testJoin);
        thread.start();

        //主线程
        for(int i=0;i<500;i++){
            if (i==200){
                thread.join();//插队
            }
            System.out.println("main"+i);
        }
    }
}
```

**输出结果：（在“main199”之前，线程是交替执行的，main199之后，线程VIP开始插队直到执行结束，main在开始继续执行！！！）**

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624092023809-941637436.png)

### 线程状态观测

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624092100901-757950376.png)

```java
//观测线程的状态
public class TestState {

    public static void main(String[] args) throws InterruptedException {

        Thread thread = new Thread(()->{
            for (int i=0;i<10;i++){
                try{
                    Thread.sleep(1000);
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
            }
            System.out.println("///////");
        });

        //观察状态
        Thread.State state = thread.getState();
        System.out.println(state);  //状态为：new，即新生的

        //观察启动后的状态
        thread.start();//启动线程
        state = thread.getState();
        System.out.println(state);//状态应为：run

        while(state!=Thread.State.TERMINATED){//只要线程不终止，就一直输出状态
            Thread.sleep(1000);
            state = thread.getState(); //更新线程状态
            System.out.println(state);
        }

        thread.start();
    }
}
```

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624092122069-926920789.png)

### 线程优先级

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624092151730-1144226649.png)

**测试线程优先级：**

```java
//测试线程的优先级
public class TestPriority {

    public static void main(String[] args) {
        //主线程默认优先级
        System.out.println(Thread.currentThread().getName()+"--->"+Thread.currentThread().getPriority());

        MyPriority myPriority = new MyPriority();

        Thread t1 = new Thread(myPriority);
        Thread t2 = new Thread(myPriority);
        Thread t3 = new Thread(myPriority);
        Thread t4 = new Thread(myPriority);
        Thread t5 = new Thread(myPriority);
        Thread t6 = new Thread(myPriority);

        //先设置优先级，再启动
        t1.start();

        t2.setPriority(1);
        t2.start();

        t3.setPriority(4);
        t3.start();

        t4.setPriority(Thread.MAX_PRIORITY);
        t4.start();


        t5.setPriority(8);
        t5.start();

        t6.setPriority(7);
        t6.start();
    }
}

class MyPriority implements Runnable{
    @Override
    public void run(){
        System.out.println(Thread.currentThread().getName()+"--->"+Thread.currentThread().getPriority());
    }
}
```

运行结果：

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624092214130-388066658.png)

## 守护(daemon)线程

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624092238322-2107933062.png)

测试守护线程：

```java
//测试守护线程
//上帝守护你
public class TestDaemon {

    public static void main(String[] args) {
        God god = new God();
        You you = new You();

        Thread thread = new Thread(god);
        thread.setDaemon(true); //默认为false表示用户线程，正常的线程都是用户线程

        thread.start();//上帝守护线程开启

        new Thread(you).start();//you 用户线程开启
    }
}

//上帝
class God implements Runnable{
    @Override
    public void run(){
        //这里设置为一直循环，但虚拟机不会等到该线程执行结束(该线程也不会自动结束)，就会将其停止，它只要确保用户线程执行完毕即可
        while(true){    
            System.out.println("s上帝保佑着你！");
        }
    }
}

//你
class You implements Runnable{
    @Override
    public void run(){
        for (int i=0;i<36500;i++){
            System.out.println("你一生都开心的活着");
        }
        System.out.println("======goodbye! world!=======");
    }
}
```

输出结果：
![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624092312851-1069566084.png)

这里的用户线程执行完毕后，守护线程依旧执行是因为虚拟机完毕需要时间，在这期间守护线程还可以一直运行！

## 线程同步

**多个线程操作同一个资源**

**并发：同一个对象被多个线程同时操作**

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624101313676-802935342.png)

**队列和锁：实现线程同步需要队列和锁**

***队列和锁的理解可以联想排队上厕所：队列就像等待上厕所的队伍，锁就像蹲坑的门，当你进去时把门关上，则其他人就进不去了，如果没有门（锁）就不能独占资源，也就没有了安全性***

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624101334902-1117191858.png)

### 三大不安全案例

```java
//不安全的买票
public class UnsafeBuyTicket {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		BuyTicket station = new BuyTicket();
		new Thread(station,"苦逼的我").start();
		new Thread(station,"牛逼的大家").start();
		new Thread(station,"可恶的黄牛").start();
	}

}
class BuyTicket implements Runnable{
	//票
	private int ticketNums = 10;
	boolean flag = true;//外部停止方式
	@Override
	public void run() {
		//买票
		while(flag)
		{
			try{
				buy();
			}catch(InterruptedException e)
			{
				e.printStackTrace();
			}
		}
	}
	private void buy() throws InterruptedException{
		//判断是否有票
		if(ticketNums<=0)
		{
			return;
		}
		
		//模拟延时
		Thread.sleep(100);
		//买票
		System.out.println(Thread.currentThread().getName()+"拿到了"+ticketNums--+"票");
	}
}
```

输出结果：（拿票混乱，且出现负数）
![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624101357836-120516376.png)

```java
//不安全的取钱
//两个人去银行取钱，账户
public class UnsafeBank {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Account a = new Account(100,"结婚基金");
		
		Drawing you = new Drawing(a,50,"你");
		Drawing girl = new Drawing(a,100,"girl");
		
		you.start();
		girl.start();
		
	}

}
//账户
class Account{
	int money;//余额
	String name;//卡名
	public Account(int money,String name)
	{
		this.money = money;
		this.name = name;
	}
}
//银行：模拟取款
class Drawing extends Thread{
	Account account;//账户
	int drawingMoney;//取了多少钱
	int nowMoney;//现在手里有多少钱
	public Drawing(Account account,int drawingMoney,String name) {
		super(name);   //定义线程名
		this.account = account;
		this.drawingMoney = drawingMoney;
	}
	//取钱
	@Override
	public void run() {
		//判断有没有钱
		if(account.money-drawingMoney<0)
		{
			System.out.println(Thread.currentThread().getName()+"钱不够");
			return;
		}
		//sleep可以放大问题的发生性
		try {
			Thread.sleep(1000);
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		//卡内余额=余额-你取的钱
		account.money = account.money-drawingMoney;
		//你手里的钱
		nowMoney = nowMoney + drawingMoney;
		System.out.println(account.name+"余额为"+account.money);
		
		//这两个操作等价
		//this.getName()=Thread.currentThread().getName()
		System.out.println(this.getName()+"手里的钱"+nowMoney);
	}
}
```

输出结果：（存款为负数）

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624101419022-1344657248.png)

```java
//线程不安全的集合
public class UnsafeList {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		List<String> list = new ArrayList<String>();
		for(int i=0;i<10000;i++)
		{
			new Thread(()->{
				list.add(Thread.currentThread().getName());
			}).start();
		}
		try {
			Thread.sleep(3000);
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		System.out.println(list.size());
	}

}
```

输出结果：（不足10000，因为存在多个线程同时看到一个标志，于是name就存在被覆盖掉的可能）

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624101437182-826328119.png)

### 同步方法及同步块(synchronized)(把不安全的改成安全的)

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624101453940-2141206983.png)

```java
//加锁，同步方法，实现安全的买票
public class UnsafeBuyTicket {

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        BuyTicket station = new BuyTicket();
        new Thread(station,"苦逼的我").start();
        new Thread(station,"牛逼的大家").start();
        new Thread(station,"可恶的黄牛").start();
    }

}
class BuyTicket implements Runnable{
    //票
    private int ticketNums = 10;
    boolean flag = true;//外部停止方式
    @Override
    public void run() {
        //买票
        while(flag)
        {
            try{
                buy();
            }catch(InterruptedException e)
            {
                e.printStackTrace();
            }
        }
    }
    
    //同步方法，锁的是BuyTicket类实例出的对象
    private synchronized void buy() throws InterruptedException{
        //判断是否有票
        if(ticketNums<=0)
        {
            return;
        }

        //模拟延时
        Thread.sleep(100);
        //买票
        System.out.println(Thread.currentThread().getName()+"拿到了"+ticketNums--+"票");
    }
}
```

输出结果:（输出结果整洁有序，没有重复，没有负数）

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624101524214-62143193.png)

#### 同步方法的弊端

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624101605341-1757957268.png)

#### 同步块

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624101648059-687469980.png)

```java
//使用方法块，找准修改的对象作为同步监视器来实现安全的取钱
//两个人去银行取钱，账户
public class UnsafeBank {

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        Account a = new Account(100,"结婚基金");

        Drawing you = new Drawing(a,50,"你");
        Drawing girl = new Drawing(a,100,"girl");

        you.start();
        girl.start();

    }

}
//账户
class Account{
    int money;//余额
    String name;//卡名
    public Account(int money,String name)
    {
        this.money = money;
        this.name = name;
    }
}
//银行：模拟取款
class Drawing extends Thread{
    Account account;//账户
    int drawingMoney;//取了多少钱
    int nowMoney;//现在手里有多少钱
    public Drawing(Account account,int drawingMoney,String name) {
        super(name);   //定义线程名
        this.account = account;
        this.drawingMoney = drawingMoney;
    }
    //取钱
    // 如果直接在run方法前加锁，默认是锁的是调用该方法的对象，即Drawing类的实例化对象，
    // 而我们这里实际上是对account这个共享资源做修改，故应该对account加锁
    @Override
    public void run() {

        // 是对account加锁，account称之为同步监视器
        // 锁的对象就是变化的量，需要增删改操作的对象
        synchronized (account){
            //判断有没有钱
            if(account.money-drawingMoney<0)
            {
                System.out.println(Thread.currentThread().getName()+"钱不够");
                return;
            }
            //sleep可以放大问题的发生性
            try {
                Thread.sleep(1000);
            }catch(Exception e)
            {
                e.printStackTrace();
            }
            //卡内余额=余额-你取的钱
            account.money = account.money-drawingMoney;
            //你手里的钱
            nowMoney = nowMoney + drawingMoney;
            System.out.println(account.name+"余额为"+account.money);

            //这两个操作等价
            //System.out.println(this.getName()+Thread.currentThread().getName());
            System.out.println(this.getName()+"手里的钱"+nowMoney);
        }

    }
}
```

输出结果：（不会出现负数了）

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624101711581-1126440846.png)

```java
//使用同步块实现线程安全的集合
public class UnsafeList {

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        List<String> list = new ArrayList<String>();

        for(int i=0;i<10000;i++)
        {
            new Thread(()->{
                //使用同步块
                synchronized (list){
                    list.add(Thread.currentThread().getName());
                }
            }).start();
        }
        try {
            Thread.sleep(3000);
        }catch(Exception e)
        {
            e.printStackTrace();
        }
        System.out.println(list.size());
    }

}
```

输出结果：（size正确）

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624101727936-1045150105.png)

#### CopyOnWriteArrayList

```java
import java.util.concurrent.CopyOnWriteArrayList;

//测试JUC安全类型的集合,使用juc下的集合不用添加同步块就可实现线程的同步
public class TestJUC {
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<String>();
        for(int i=0;i<10000;i++)
        {
            new Thread(()->{
                list.add(Thread.currentThread().getName());
            }).start();
        }
        try {
            Thread.sleep(3000);
        }catch(Exception e)
        {
            e.printStackTrace();
        }
        System.out.println(list.size());
    }

}
```

### 死锁

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624101754214-600828114.png)

**注意：一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”问题！**

**制造死锁：**

```java
//死锁：多个线程相互抱着对方需要的资源，然后形成死锁
public class DeadLock {

    public static void main(String[] args) {
        Makeup g1 = new Makeup(0,"灰姑娘");
        Makeup g2 = new Makeup(1,"白雪公主");

        g1.start();
        g2.start();
    }
}

//口红
class Lipstick{

}

//镜子
class Mirror{

}

class Makeup extends Thread{

    //需要的资源只有一份，用static来保证只有一份
    static Lipstick lipstick  = new Lipstick();
    static Mirror mirror = new Mirror();

    int choice; //选择
    String girlName; //使用化妆品的人

    Makeup(int chioce,String girlName){
        this.choice = chioce;
        this.girlName = girlName;
    }

    @Override
    public void run(){
        //化妆
        try {
            makeup();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    //化妆，互相持有对方的锁，就是需要拿到对象的资源
    private void makeup() throws InterruptedException {
        if (choice==0){
            synchronized (lipstick){
                System.out.println(this.girlName+"获得口红的锁");
                Thread.sleep(1000);
                //下面代码是在synchronized (lipstick){}里面
                synchronized (mirror){ //一秒钟后想获得镜子
                    System.out.println(this.girlName+"获得镜子的锁");
                }
            }
        }else{
            synchronized (mirror){  //获得镜子的锁、
                System.out.println(this.girlName+"获得镜子的锁");
                Thread.sleep(2000);
                //下面代码是在synchronized (mirror){}里面
                synchronized (lipstick){  //一秒后想获得镜子
                    System.out.println(this.girlName+"获得口红的锁");
                }
            }
        }
    }
}
```

**这种代码就是产生死锁的关键点：(一个同步块包含两个对象)**

```java
synchronized (lipstick){
                System.out.println(this.girlName+"获得口红的锁");
                Thread.sleep(1000);
                //下面代码是在synchronized (lipstick){}里面
                synchronized (mirror){ //一秒钟后想获得镜子
                    System.out.println(this.girlName+"获得镜子的锁");
                }
```

输出结果：(发生死锁)

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624101830877-1427037505.png)

**解除死锁：**

```java
//解除死锁
public class DeadLock {

    public static void main(String[] args) {
        Makeup g1 = new Makeup(0,"灰姑娘");
        Makeup g2 = new Makeup(1,"白雪公主");

        g1.start();
        g2.start();
    }
}

//口红
class Lipstick{

}

//镜子
class Mirror{

}

class Makeup extends Thread{

    //需要的资源只有一份，用static来保证只有一份
    static Lipstick lipstick  = new Lipstick();
    static Mirror mirror = new Mirror();

    int choice; //选择
    String girlName; //使用化妆品的人

    Makeup(int chioce,String girlName){
        this.choice = chioce;
        this.girlName = girlName;
    }

    @Override
    public void run(){
        //化妆
        try {
            makeup();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    //化妆，互相持有对方的锁，就是需要拿到对象的资源
    private void makeup() throws InterruptedException {
        if (choice==0){
            synchronized (lipstick){
                System.out.println(this.girlName+"获得口红的锁");
                Thread.sleep(1000);
            }
            //将下面代码从上面同步块中拿出，即可化解死锁
            synchronized (mirror){ //一秒钟后想获得镜子
                System.out.println(this.girlName+"获得镜子的锁");
            }
        }else{
            synchronized (mirror){  //获得镜子的锁、
                System.out.println(this.girlName+"获得镜子的锁");
                Thread.sleep(2000);
            }
            //将下面代码从上面同步块中拿出，即可化解死锁
            synchronized (lipstick){  //一秒后想获得镜子
                System.out.println(this.girlName+"获得口红的锁");
            }
        }
    }
}
```

输出结果：（不发生死锁）

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624101852361-1766564923.png)

### 避免死锁的方法

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624101919869-1239375767.png)

### Lock(锁)

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624101953136-1071919238.png)

**下面使用可重入锁ReentrantLock对共享资源进行显示加锁、解锁：**

```java
import java.util.concurrent.locks.ReentrantLock;

public class TestLock {
    public static void main(String[] args) {
        TestLock2 testLock2 = new TestLock2();

        new Thread(testLock2).start();
        new Thread(testLock2).start();
        new Thread(testLock2).start();
    }
}

class TestLock2 implements Runnable{

    int ticketNums = 10;

    //定义lock锁
    private final ReentrantLock lock = new ReentrantLock();

    @Override
    public void run(){
        while(true){

            try {
                lock.lock(); //加锁
                if (ticketNums>0){
                    try{
                        Thread.sleep(1000);
                    }catch (InterruptedException e){
                        e.printStackTrace();
                    }
                    System.out.println(ticketNums--);
                }else{
                    break;
                }
            }finally {
                lock.unlock(); //解锁
            }

        }
    }
}
```

输出结果：

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624102020912-1415938587.png)

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624102046302-233476146.png)

### synchronized与Lock的对比

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624102105105-512742546.png)

## 线程协作

**生产者消费者问题**

### 线程通信

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624102131100-245144526.png)

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624102206854-1370208617.png)

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624102255048-662503320.png)

#### 解决方式1

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624102313336-186853987.png)

```java
//测试:生产者消费者模型 --->利用缓存区解决：管程法

public class TestPC {

    public static void main(String[] args) {

        SyncContainer container = new SyncContainer();

        new ProviderThread(container).start();
        new ConsumerThread(container).start();

    }
}

//生产者
class ProviderThread extends Thread {

    //创建好的缓冲区
    private SyncContainer syncContainer;

    public ProviderThread(SyncContainer syncContainer) {
        this.syncContainer = syncContainer;
    }

    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {
            syncContainer.push(new Product(i));
            System.out.println("生产了第" + i + "只鸡!");
        }
    }
}

//消费者
class ConsumerThread extends Thread {

    private SyncContainer syncContainer;

    public ConsumerThread(SyncContainer syncContainer) {
        this.syncContainer = syncContainer;
    }

    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {
            Product pop = syncContainer.pop();
            System.out.println("消费了第"+ pop.getId() + "号产品");
        }
    }
}

//产品
class Product {
    private int id;

    public Product(int id) {
        this.id = id;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }
}

//缓冲区
class SyncContainer {

    //容器大小，product[0]为空，不使用，即最多放10件产品
    Product[] products = new Product[11];
    //容器计数器
    int count = 0;

    //生产者放入产品
    public synchronized void push(Product product){
        //如果容器满了,就要等待消费者
        //这里为什么减2才能实现最多连续存储10只鸡，而减1会出现最多连续存储11只鸡，我不清楚，比较费解
        if(count == products.length-2) {
            //等待消费者消费,生产者等待
            try {
                this.wait();
            } catch (InterruptedException e){
                e.printStackTrace();
            }
        }
        //如果容器没有满,我们就要丢入产品
        count++;
        products[count] = product;


        //可以通知消费者消费
        this.notifyAll();
    }


    //消费者消费产品
    public synchronized Product pop(){
        //判断容器是否为空
        if(count == 0){
            //等待生产者生产.消费者等待
            try {
                this.wait();
            } catch (InterruptedException e){
                e.printStackTrace();
            }
        }

        //如果可以消费

        Product product =  products[count];
        count--;

        //通知生产者生产
        this.notifyAll();
        return product;
    }
}
```

小疑问：

```java
count == products.length-2 //容器实际能存放10件产品，数组长度为11，减2则count为9，对应product[9],而实际可以存放至product[10],因为下标为0时，不存放产品。为什么-2才能最大连续打至出生产了第10只鸡，而-1会连续打印至生产第11只鸡
```

输出结果：（符合要求）

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624102350579-1898786747.png)

#### 解决方式2

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624102419670-707120688.png)

```java
//测试生产者消费者问题2：信号灯法，标志位解决
public class TestPC2 {

    public static void main(String[] args) {
        TV tv = new TV();
        new Player(tv).start();
        new Watcher(tv).start();
    }
}

//生产者-->演员
class Player extends Thread{

    TV tv;
    public Player(TV tv){
        this.tv = tv;
    }

    @Override
    public void run(){
        for (int i = 0;i<20;i++){
            if (i%2==0){
                this.tv.play("快乐大本营播放中");
            }else{
                this.tv.play("抖音：记录美好生活");
            }
        }
    }
}

//消费之-->观众
class Watcher extends Thread{
    TV tv;
    public Watcher(TV tv){
        this.tv = tv;
    }

    @Override
    public void run(){
        for (int i=0;i<20;i++){
            tv.watch();
        }
    }

}

//产品-->节目
class TV {
    //演员表演，观众等待   T
    //观众观看，演员等待   F
    String voice; //表演的节目
    boolean flag = true;  //flag为真时，观众等待，为假时演员等待

    //表演
    public synchronized void play(String voice){

        if (!flag){
            try{
                this.wait();
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
        System.out.println("演员表演了："+voice);
        //通知观众观看
        this.notifyAll(); //通知唤醒
        this.voice = voice;
        this.flag = !this.flag;
    }

    //观看
    public synchronized void watch(){
        if (flag){
            try {
                this.wait();
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
        System.out.println("观看了："+voice);
        //通知演员表演
        this.notifyAll();
        this.flag = !this.flag;
    }
}
```

输出结果：

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624102441333-1979534627.png)

## 使用线程池

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624102454841-1862576344.png)

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624102515168-1544155871.png)

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

//测试线程池
public class TestPool {

    public static void main(String[] args) {
        //1.创建服务，创建线程池
        //newFixedThreadPool 参数为线程池大小
        ExecutorService service = Executors.newFixedThreadPool(10);

        //执行runnable接口实现类对象
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        
        //2.关闭连接
        service.shutdown();
    }
}

class MyThread implements Runnable{
    @Override
    public void run(){
        System.out.println(Thread.currentThread().getName());
    }
}
```

输出结果：

![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624102531697-144391089.png)

```java
package com.ztx.gaoji;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;

//JUC并发编程
import java.util.concurrent.*;

public class TestCallable implements Callable<Boolean> {

    private String url;
    private String name;

    public TestCallable(String url,String name){
        this.url = url;
        this.name = name;
    }

    @Override
    public Boolean call() throws Exception {
        //下载图片
        WebDownloader webDownloader = new WebDownloader();//下载器
        webDownloader.downloader(url,name);//下载文件的方式
        System.out.println("下载了图片-->"+name);
        return true;
    }

    //启动线程
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        TestCallable t1 = new TestCallable("https://img2020.cnblogs.com/blog/1732557/202006/1732557-20200617142339091-966351471.png","你好1.jpg");
        TestCallable t2 = new TestCallable("https://img2020.cnblogs.com/blog/1732557/202006/1732557-20200617142428143-1598758167.png","你好2.jpg");
        TestCallable t3 = new TestCallable("https://img2020.cnblogs.com/blog/1732557/202006/1732557-20200617142459110-1793347461.png","你好3.jpg");

        //创建执行服务：
        ExecutorService ser = Executors.newFixedThreadPool(3);

        //提交执行：
        Future<Boolean> result1 = ser.submit(t1);
        Future<Boolean> result2 = ser.submit(t2);
        Future<Boolean> result3 = ser.submit(t3);

        //获取结果
        boolean r1 = result1.get();
        boolean r2 = result2.get();
        boolean r3 = result3.get();

        //判断线程是否顺利结束或者有异常
        System.out.println(r1);
        System.out.println(r2);
        System.out.println(r3);

        //关闭服务
        ser.shutdownNow();
    }
}



//下载图片
class WebDownloader{

    //下载方法
    public void downloader(String url,String name){
        try {
            FileUtils.copyURLToFile(new URL(url),new File(name));
        } catch (IOException e) {
            e.printStackTrace();
            //输出异常信息
            System.out.println("downloader方法出现异常");
        }
    }

}
```

输出结果：
![img](https://gitee.com/xudongyin/img/raw/master/img/1732557-20200624102547059-935996720.png)